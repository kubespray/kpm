local initSeed = randAlpha(256);

{
  # KPM extended std

  # Returns hash of the string representation of an object.
  hash(data, hashtype='sha1'):: (
    std.native("hash")(std.toString(data), hashtype)
  ),

  # Converts an object to yaml string
  to_yaml(data):: (
    std.native("to_yaml")(std.toString(data))
  ),

  # Random alpha-numeric string of length `size`
  randAlphaNum(size=32, seed=""):: (
    std.native("rand_alphanum")(std.toString(size), seed=seed)
  ),

  # Random alpha string of length `size`
  randAlpha(size=32, seed=""):: (
    std.native("rand_alpha")(std.toString(size), seed=seed)
  ),

  # Random numeric string of length `size`
  randInt(size=32, seed=""):: (
    std.native("randint")(std.toString(size), seed=seed)
  ),

  # Generate privateKeys.
  # Keytype choices: 'rsa', 'ecdsa', 'dsa'.
  # key is to generate a unique key per run
  genPrivateKey(keytype, key=""):: (
    std.native("privatekey")(keytype, key=key, seed=initSeed)
  ),

  # Render jinja2 template
  jinja2(template, env):: (
    std.native("jinja2")(template, std.toString(env))
  ),

  # Convert json string to object
  jsonLoads(data):: (
    std.native("json_loads")(data)
  ),

  # Convert yaml string to object
  yamlLoads(data):: (
    std.native("yaml_loads")(data)),

  # Generate a sequence array from 1 to i
  seq(i):: (
    [x for x in std.range(1, i)]
  ),



###########################################3
# KPM internals

  variables(vars, target):: (
    std.mergePatch(vars, target)
  ),

  deploy(dep):: (
    dep
  ),

  shards(s, target):: (
    if std.type(target) == 'null' then
      s
    else if std.type(target) == "object" then
      std.mergePatch(s, target)
    else if std.type(target) == "array" then
      if std.length(target) == 0 then
        s
      else
        target
    else if std.type(target) == "number" then
      [{ name: x } for x in self.seq(target)]
    else
      error "Bad shard type: %s (%s)" % [target, std.type(target)]
  ),

  shard_count(n):: ([{ name: x } for x in std.range(1, n)]),

  shard_list(shard, shards):: (
    if shard == "true" || std.type(shard) == "boolean" then
      shards
    else if std.type(shard) == "string" then
      if std.type(shards[shard]) == "number" then
        self.shard_count(shards[shard])
      else
        shards[shard]
    else if std.type(shard) == "number" then
      self.shard_count(shard)
    else
      error "Unknow shard value: %s (%s)" % [shard, std.type(shard)]
  ),

  template_format(resource):: (
    resource + { template: resource.template % resource.variables }
  ),

  template_jinja2(resource):: (
    resource + { template: self.jinja2(resource.template, resource.variables) }
  ),

  template(resource):: (
    if std.objectHas(resource, "expander") == false then
      resource
    else if resource.expander == "format" then
      self.template_format(resource)
    else if resource.expander == "jinja2" then
      self.template_jinja2(resource)
    else
      error "Unknown expander: %s" % [resource.expander]
  ),

  sharded_resource(resource, shards, variables):: (
    local resource_shards = self.shard_list(resource.sharded, shards);
    [
      local extra = {
        shard: shard.name,
        name: "%s-%s" % [resource.name, shard.name],
      };

      local var = if std.objectHas(shard, "variables") == true then
        { variables: variables + extra +
                     shard.variables + { shards: resource_shards } }
      else
        { variables: variables + extra + { shards: resource_shards } };

      local r = resource + extra + var;
      self.template(r) for shard in resource_shards]
  ),

  resources(resources, shards, variables):: (
    std.flattenArrays([
      if std.objectHas(resource, "sharded") then
        self.sharded_resource(resource, shards, variables)
      else
        [self.template(resource { variables: variables { name: resource.name } })]
      for resource in resources])
  ),


}
